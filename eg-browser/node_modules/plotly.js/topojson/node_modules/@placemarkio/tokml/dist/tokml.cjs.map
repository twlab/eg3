{"version":3,"file":"tokml.cjs","sources":["../node_modules/.pnpm/unist-builder@3.0.1/node_modules/unist-builder/lib/index.js","../node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/core.js","../node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/util/format-basic.js","../node_modules/.pnpm/stringify-entities@4.0.4/node_modules/stringify-entities/lib/index.js","../node_modules/.pnpm/xast-util-to-xml@3.0.2/node_modules/xast-util-to-xml/lib/util-escape.js","../node_modules/.pnpm/xast-util-to-xml@3.0.2/node_modules/xast-util-to-xml/lib/name.js","../node_modules/.pnpm/ccount@2.0.1/node_modules/ccount/index.js","../node_modules/.pnpm/xast-util-to-xml@3.0.2/node_modules/xast-util-to-xml/lib/value.js","../node_modules/.pnpm/xast-util-to-xml@3.0.2/node_modules/xast-util-to-xml/lib/element.js","../node_modules/.pnpm/xast-util-to-xml@3.0.2/node_modules/xast-util-to-xml/lib/text.js","../node_modules/.pnpm/xast-util-to-xml@3.0.2/node_modules/xast-util-to-xml/lib/comment.js","../node_modules/.pnpm/xast-util-to-xml@3.0.2/node_modules/xast-util-to-xml/lib/doctype.js","../node_modules/.pnpm/xast-util-to-xml@3.0.2/node_modules/xast-util-to-xml/lib/instruction.js","../node_modules/.pnpm/xast-util-to-xml@3.0.2/node_modules/xast-util-to-xml/lib/cdata.js","../node_modules/.pnpm/xast-util-to-xml@3.0.2/node_modules/xast-util-to-xml/lib/raw.js","../node_modules/.pnpm/xast-util-to-xml@3.0.2/node_modules/xast-util-to-xml/lib/one.js","../node_modules/.pnpm/xast-util-to-xml@3.0.2/node_modules/xast-util-to-xml/lib/index.js","../node_modules/.pnpm/xastscript@3.1.1/node_modules/xastscript/lib/index.js","../lib/index.ts"],"sourcesContent":["/**\n * @typedef {import('unist').Node} Node\n */\n\n/**\n * @typedef {Array<Node> | string} ChildrenOrValue\n *   List to use as `children` or value to use as `value`.\n *\n * @typedef {Record<string, unknown>} Props\n *   Other fields to add to the node.\n */\n\n/**\n * Build a node.\n *\n * @param type\n *   Node type.\n * @param props\n *   Fields assigned to node.\n * @param value\n *   Children of node or value of `node` (cast to string).\n * @returns\n *   Built node.\n */\nexport const u =\n  /**\n   * @type {(\n   *   (<T extends string>(type: T) => {type: T}) &\n   *   (<T extends string, P extends Props>(type: T, props: P) => {type: T} & P) &\n   *   (<T extends string>(type: T, value: string) => {type: T, value: string}) &\n   *   (<T extends string, P extends Props>(type: T, props: P, value: string) => {type: T, value: string} & P) &\n   *   (<T extends string, C extends Array<Node>>(type: T, children: C) => {type: T, children: C}) &\n   *   (<T extends string, P extends Props, C extends Array<Node>>(type: T, props: P, children: C) => {type: T, children: C} & P)\n   * )}\n   */\n  (\n    /**\n     * @param {string} type\n     * @param {Props | ChildrenOrValue | null | undefined} [props]\n     * @param {ChildrenOrValue | null | undefined} [value]\n     * @returns {Node}\n     */\n    function (type, props, value) {\n      /** @type {Node} */\n      const node = {type: String(type)}\n\n      if (\n        (value === undefined || value === null) &&\n        (typeof props === 'string' || Array.isArray(props))\n      ) {\n        value = props\n      } else {\n        Object.assign(node, props)\n      }\n\n      if (Array.isArray(value)) {\n        // @ts-expect-error: create a parent.\n        node.children = value\n      } else if (value !== undefined && value !== null) {\n        // @ts-expect-error: create a literal.\n        node.value = String(value)\n      }\n\n      return node\n    }\n  )\n","/**\n * @typedef CoreOptions\n * @property {ReadonlyArray<string>} [subset=[]]\n *   Whether to only escape the given subset of characters.\n * @property {boolean} [escapeOnly=false]\n *   Whether to only escape possibly dangerous characters.\n *   Those characters are `\"`, `&`, `'`, `<`, `>`, and `` ` ``.\n *\n * @typedef FormatOptions\n * @property {(code: number, next: number, options: CoreWithFormatOptions) => string} format\n *   Format strategy.\n *\n * @typedef {CoreOptions & FormatOptions & import('./util/format-smart.js').FormatSmartOptions} CoreWithFormatOptions\n */\n\nconst defaultSubsetRegex = /[\"&'<>`]/g\nconst surrogatePairsRegex = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g\nconst controlCharactersRegex =\n  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape\n  /[\\x01-\\t\\v\\f\\x0E-\\x1F\\x7F\\x81\\x8D\\x8F\\x90\\x9D\\xA0-\\uFFFF]/g\nconst regexEscapeRegex = /[|\\\\{}()[\\]^$+*?.]/g\n\n/** @type {WeakMap<ReadonlyArray<string>, RegExp>} */\nconst subsetToRegexCache = new WeakMap()\n\n/**\n * Encode certain characters in `value`.\n *\n * @param {string} value\n * @param {CoreWithFormatOptions} options\n * @returns {string}\n */\nexport function core(value, options) {\n  value = value.replace(\n    options.subset\n      ? charactersToExpressionCached(options.subset)\n      : defaultSubsetRegex,\n    basic\n  )\n\n  if (options.subset || options.escapeOnly) {\n    return value\n  }\n\n  return (\n    value\n      // Surrogate pairs.\n      .replace(surrogatePairsRegex, surrogate)\n      // BMP control characters (C0 except for LF, CR, SP; DEL; and some more\n      // non-ASCII ones).\n      .replace(controlCharactersRegex, basic)\n  )\n\n  /**\n   * @param {string} pair\n   * @param {number} index\n   * @param {string} all\n   */\n  function surrogate(pair, index, all) {\n    return options.format(\n      (pair.charCodeAt(0) - 0xd800) * 0x400 +\n        pair.charCodeAt(1) -\n        0xdc00 +\n        0x10000,\n      all.charCodeAt(index + 2),\n      options\n    )\n  }\n\n  /**\n   * @param {string} character\n   * @param {number} index\n   * @param {string} all\n   */\n  function basic(character, index, all) {\n    return options.format(\n      character.charCodeAt(0),\n      all.charCodeAt(index + 1),\n      options\n    )\n  }\n}\n\n/**\n * A wrapper function that caches the result of `charactersToExpression` with a WeakMap.\n * This can improve performance when tooling calls `charactersToExpression` repeatedly\n * with the same subset.\n *\n * @param {ReadonlyArray<string>} subset\n * @returns {RegExp}\n */\nfunction charactersToExpressionCached(subset) {\n  let cached = subsetToRegexCache.get(subset)\n\n  if (!cached) {\n    cached = charactersToExpression(subset)\n    subsetToRegexCache.set(subset, cached)\n  }\n\n  return cached\n}\n\n/**\n * @param {ReadonlyArray<string>} subset\n * @returns {RegExp}\n */\nfunction charactersToExpression(subset) {\n  /** @type {Array<string>} */\n  const groups = []\n  let index = -1\n\n  while (++index < subset.length) {\n    groups.push(subset[index].replace(regexEscapeRegex, '\\\\$&'))\n  }\n\n  return new RegExp('(?:' + groups.join('|') + ')', 'g')\n}\n","/**\n * The smallest way to encode a character.\n *\n * @param {number} code\n * @returns {string}\n */\nexport function formatBasic(code) {\n  return '&#x' + code.toString(16).toUpperCase() + ';'\n}\n","/**\n * @typedef {import('./core.js').CoreOptions & import('./util/format-smart.js').FormatSmartOptions} Options\n * @typedef {import('./core.js').CoreOptions} LightOptions\n */\n\nimport {core} from './core.js'\nimport {formatSmart} from './util/format-smart.js'\nimport {formatBasic} from './util/format-basic.js'\n\n/**\n * Encode special characters in `value`.\n *\n * @param {string} value\n *   Value to encode.\n * @param {Options} [options]\n *   Configuration.\n * @returns {string}\n *   Encoded value.\n */\nexport function stringifyEntities(value, options) {\n  return core(value, Object.assign({format: formatSmart}, options))\n}\n\n/**\n * Encode special characters in `value` as hexadecimals.\n *\n * @param {string} value\n *   Value to encode.\n * @param {LightOptions} [options]\n *   Configuration.\n * @returns {string}\n *   Encoded value.\n */\nexport function stringifyEntitiesLight(value, options) {\n  return core(value, Object.assign({format: formatBasic}, options))\n}\n","import {stringifyEntitiesLight} from 'stringify-entities'\n\n// eslint-disable-next-line no-control-regex\nconst noncharacter = /[\\u0000-\\u0008\\u000B\\u000C\\u000E-\\u001F]/g\n\n/**\n * Escape a string.\n *\n * @param {string} value\n *   Raw string.\n * @param {Array<string>} subset\n *   Characters to escape.\n * @param {RegExp | null | undefined} [unsafe]\n *   Regex to scope `subset` to.\n * @returns {string}\n *   Escaped string.\n */\nexport function escape(value, subset, unsafe) {\n  const result = clean(value)\n\n  return unsafe ? result.replace(unsafe, encode) : encode(result)\n\n  /**\n   * Actually escape characters.\n   *\n   * @param {string} value\n   *   Raw value.\n   * @returns {string}\n   *   Copy of `value`, escaped.\n   */\n  function encode(value) {\n    return stringifyEntitiesLight(value, {subset})\n  }\n}\n\n/**\n * Remove non-characters.\n *\n * @param {string} value\n *   Raw value.\n * @returns {string}\n *   Copy of `value` with non-characters removed.\n */\nfunction clean(value) {\n  return String(value || '').replace(noncharacter, '')\n}\n","import {escape} from './util-escape.js'\n\nconst subset = ['\\t', '\\n', ' ', '\"', '&', \"'\", '/', '<', '=', '>']\n\n/**\n * Encode a node name.\n *\n * @param {string} value\n *   Raw name.\n * @returns {string}\n *   Escaped name.\n */\nexport function name(value) {\n  return escape(value, subset)\n}\n","/**\n * Count how often a character (or substring) is used in a string.\n *\n * @param {string} value\n *   Value to search in.\n * @param {string} character\n *   Character (or substring) to look for.\n * @return {number}\n *   Number of times `character` occurred in `value`.\n */\nexport function ccount(value, character) {\n  const source = String(value)\n\n  if (typeof character !== 'string') {\n    throw new TypeError('Expected character')\n  }\n\n  let count = 0\n  let index = source.indexOf(character)\n\n  while (index !== -1) {\n    count++\n    index = source.indexOf(character, index + character.length)\n  }\n\n  return count\n}\n","/**\n * @typedef {import('./index.js').State} State\n */\n\nimport {ccount} from 'ccount'\nimport {escape} from './util-escape.js'\n\n/**\n * Serialize an attribute value.\n *\n * @param {string} value\n *   Raw attribute value.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized attribute value.\n */\nexport function value(value, state) {\n  const result = String(value)\n  let quote = state.options.quote || '\"'\n\n  if (state.options.quoteSmart) {\n    const other = quote === '\"' ? \"'\" : '\"'\n\n    if (ccount(result, quote) > ccount(result, other)) {\n      quote = other\n    }\n  }\n\n  return quote + escape(result, ['<', '&', quote]) + quote\n}\n","/**\n * @typedef {import('xast').Element} Element\n * @typedef {import('./index.js').State} State\n */\n\nimport {all} from './one.js'\nimport {name} from './name.js'\nimport {value} from './value.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Serialize an element.\n *\n * @param {Element} node\n *   xast element node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized XML.\n */\nexport function element(node, state) {\n  const nodeName = name(node.name)\n  const content = all(node, state)\n  const attributes = node.attributes || {}\n  const close = content ? false : state.options.closeEmptyElements\n  /** @type {Array<string>} */\n  const attrs = []\n  /** @type {string} */\n  let key\n\n  for (key in attributes) {\n    if (own.call(attributes, key)) {\n      const result = attributes[key]\n\n      if (result !== null && result !== undefined) {\n        attrs.push(name(key) + '=' + value(result, state))\n      }\n    }\n  }\n\n  return (\n    '<' +\n    nodeName +\n    (attrs.length === 0 ? '' : ' ' + attrs.join(' ')) +\n    (close ? (state.options.tightClose ? '' : ' ') + '/' : '') +\n    '>' +\n    content +\n    (close ? '' : '</' + nodeName + '>')\n  )\n}\n","/**\n * @typedef {import('xast').Text} Text\n * @typedef {import('./index.js').Raw} Raw\n */\n\nimport {escape} from './util-escape.js'\n\nconst subset = ['&', '<']\n\n/**\n * Serialize a text.\n *\n * @param {Text | Raw} node\n *   xast text node (or raw).\n * @returns {string}\n *   Serialized XML.\n */\nexport function text(node) {\n  return escape(node.value, subset)\n}\n","/**\n * @typedef {import('xast').Comment} Comment\n */\n\nimport {escape} from './util-escape.js'\n\n/**\n * Serialize a comment.\n *\n * @param {Comment} node\n *   xast comment node.\n * @returns {string}\n *   Serialized XML.\n */\nexport function comment(node) {\n  return '<!--' + escape(node.value, ['-']) + '-->'\n}\n","/**\n * @typedef {import('xast').Doctype} Doctype\n * @typedef {import('./index.js').State} State\n */\n\nimport {name} from './name.js'\nimport {value} from './value.js'\n\n/**\n * Serialize a doctype.\n *\n * @param {Doctype} node\n *   xast doctype node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized XML.\n */\nexport function doctype(node, state) {\n  const nodeName = name(node.name)\n  const pub = node.public\n  const sys = node.system\n  let result = '<!DOCTYPE'\n\n  if (nodeName !== '') {\n    result += ' ' + nodeName\n  }\n\n  if (pub) {\n    result += ' PUBLIC ' + value(pub, state)\n  } else if (sys) {\n    result += ' SYSTEM'\n  }\n\n  if (sys) {\n    result += ' ' + value(sys, state)\n  }\n\n  return result + '>'\n}\n","/**\n * @typedef {import('xast').Instruction} Instruction\n */\n\nimport {escape} from './util-escape.js'\nimport {name} from './name.js'\n\nconst unsafe = /\\?>/g\nconst subset = ['>']\n\n/**\n * Serialize an instruction.\n *\n * @param {Instruction} node\n *   xast instruction node.\n * @returns {string}\n *   Serialized XML.\n */\nexport function instruction(node) {\n  const nodeName = name(node.name) || 'x'\n  const result = escape(node.value, subset, unsafe)\n  return '<?' + nodeName + (result ? ' ' + result : '') + '?>'\n}\n","/**\n * @typedef {import('xast').Cdata} Cdata\n */\n\nimport {escape} from './util-escape.js'\n\nconst unsafe = /]]>/g\nconst subset = ['>']\n\n/**\n * Serialize a CDATA section.\n *\n * @param {Cdata} node\n *   xast cdata node.\n * @returns {string}\n *   Serialized XML.\n */\nexport function cdata(node) {\n  return '<![CDATA[' + escape(node.value, subset, unsafe) + ']]>'\n}\n","/**\n * @typedef {import('./index.js').Raw} Raw\n * @typedef {import('./index.js').State} State\n */\n\nimport {text} from './text.js'\n\n/**\n * Serialize a (non-standard) raw.\n *\n * @param {Raw} node\n *   xast raw node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized XML.\n */\nexport function raw(node, state) {\n  return state.options.allowDangerousXml ? node.value : text(node)\n}\n","/**\n * @typedef {import('unist').Parent} UnistParent\n * @typedef {import('xast').Root} Root\n * @typedef {import('xast').RootChildMap} RootChildMap\n * @typedef {import('./index.js').State} State\n */\n\n/**\n * @typedef {Root | RootChildMap[keyof RootChildMap]} Node\n * @typedef {Extract<Node, UnistParent>} Parent\n * @typedef {Parent['children'][number]} Child\n */\n\nimport {element} from './element.js'\nimport {text} from './text.js'\nimport {comment} from './comment.js'\nimport {doctype} from './doctype.js'\nimport {instruction} from './instruction.js'\nimport {cdata} from './cdata.js'\nimport {raw} from './raw.js'\n\nconst own = {}.hasOwnProperty\n\nconst handlers = {\n  root: all,\n  element,\n  text,\n  comment,\n  doctype,\n  instruction,\n  cdata,\n  raw\n}\n\n/**\n * Serialize a node.\n *\n * @param {Node} node\n *   xast node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized XML.\n */\nexport function one(node, state) {\n  const type = node && node.type\n\n  if (!type) {\n    throw new Error('Expected node, not `' + node + '`')\n  }\n\n  if (!own.call(handlers, type)) {\n    throw new Error('Cannot compile unknown node `' + type + '`')\n  }\n\n  const handle = handlers[type]\n  // @ts-expect-error hush, node matches `type`.\n  const result = handle(node, state)\n\n  return result\n}\n\n/**\n * Serialize all children of `parent`.\n *\n * @param {Parent} parent\n *   xast parent node.\n * @param {State} state\n *   Info passed around about the current state.\n * @returns {string}\n *   Serialized XML.\n */\nexport function all(parent, state) {\n  /** @type {Array<Child>} */\n  const children = (parent && parent.children) || []\n  let index = -1\n  /** @type {Array<string>} */\n  const results = []\n\n  while (++index < children.length) {\n    results[index] = one(children[index], state)\n  }\n\n  return results.join('')\n}\n","/**\n * @typedef {import('xast').Literal} Literal\n * @typedef {import('xast').Root} Root\n * @typedef {import('xast').RootChildMap} RootChildMap\n */\n\n/**\n * @typedef {Literal & {type: 'raw'}} Raw\n * @typedef {Root | RootChildMap[keyof RootChildMap]} Node\n *\n * @typedef {'\"' | \"'\"} Quote\n *   XML quotes for attribute values.\n *\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [allowDangerousXml=false]\n *   Allow `raw` nodes and insert them as raw XML.\n *\n *   When `false`, `Raw` nodes are encoded.\n *\n *   > ⚠️ **Danger**: only set this if you completely trust the content.\n * @property {boolean | null | undefined} [closeEmptyElements=false]\n *   Close elements without any content with slash (`/`) on the opening tag\n *   instead of an end tag: `<circle />` instead of `<circle></circle>`.\n *\n *   See `tightClose` to control whether a space is used before the slash.\n * @property {Quote | null | undefined} [quote='\"']\n *   Preferred quote to use.\n * @property {boolean | null | undefined} [quoteSmart=false]\n *   Use the other quote if that results in less bytes.\n * @property {boolean | null | undefined} [tightClose=false]\n *   Do not use an extra space when closing self-closing elements: `<circle/>`\n *   instead of `<circle />`.\n *\n *   > 👉 **Note**: only used if `closeEmptyElements: true`.\n *\n * @typedef State\n *   Info passed around about the current state.\n * @property {Options} options\n *   Configuration.\n */\n\nimport {one} from './one.js'\n\n/**\n * Serialize a xast tree to XML.\n *\n * @param {Node | Array<Node>} tree\n *   xast node(s) to serialize.\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {string}\n *   Serialized XML.\n */\nexport function toXml(tree, options) {\n  /** @type {State} */\n  const state = {options: options || {}}\n\n  // Make sure the quote is valid.\n  if (\n    typeof state.options.quote === 'string' &&\n    state.options.quote !== '\"' &&\n    state.options.quote !== \"'\"\n  ) {\n    throw new Error(\n      'Invalid quote `' + state.options.quote + '`, expected `\\'` or `\"`'\n    )\n  }\n\n  /** @type {Node} */\n  // @ts-expect-error Assume no `root` in `node`.\n  const node = Array.isArray(tree) ? {type: 'root', children: tree} : tree\n\n  return one(node, state)\n}\n","/**\n * @typedef {import('xast').Root} Root\n * @typedef {import('xast').Element} Element\n */\n\n/**\n * @typedef {Root['children'][number]} Content\n * @typedef {Content | Root} Node\n *   Any concrete `xast` node.\n *\n * @typedef {Root | Element} Result\n *   Result from a `x` call.\n *\n * @typedef {string | number | boolean | null | undefined} Value\n *   Attribute value\n * @typedef {{[attribute: string]: Value}} Attributes\n *   Acceptable value for element properties.\n *\n * @typedef {string | number | null | undefined} PrimitiveChild\n *   Primitive children, either ignored (nullish), or turned into text nodes.\n * @typedef {Array<Node | PrimitiveChild>} ArrayChild\n *   List of children.\n * @typedef {Node | PrimitiveChild | ArrayChild} Child\n *   Acceptable child value.\n *\n * @typedef {import('./jsx-classic.js').Element} x.JSX.Element\n * @typedef {import('./jsx-classic.js').IntrinsicAttributes} x.JSX.IntrinsicAttributes\n * @typedef {import('./jsx-classic.js').IntrinsicElements} x.JSX.IntrinsicElements\n * @typedef {import('./jsx-classic.js').ElementChildrenAttribute} x.JSX.ElementChildrenAttribute\n */\n\n/**\n * Create XML trees in xast.\n *\n * @param name\n *   Qualified name.\n *\n *   Case sensitive and can contain a namespace prefix (such as `rdf:RDF`).\n *   When string, an `Element` is built.\n *   When nullish, a `Root` is built instead.\n * @param attributes\n *   Attributes of the element.\n * @param children\n *   Children of the node.\n * @returns\n *   `Element` or `Root`.\n */\nexport const x =\n  /**\n   * @type {{\n   *   (): Root\n   *   (name: null | undefined, ...children: Array<Child>): Root\n   *   (name: string, attributes?: Attributes, ...children: Array<Child>): Element\n   *   (name: string, ...children: Array<Child>): Element\n   * }}\n   */\n  (\n    /**\n     * @param {string | null | undefined} [name]\n     * @param {Attributes | Child | null | undefined} [attributes]\n     * @param {Array<Child>} children\n     * @returns {Result}\n     */\n    function (name, attributes, ...children) {\n      let index = -1\n      /** @type {Result} */\n      let node\n\n      if (name === undefined || name === null) {\n        node = {type: 'root', children: []}\n        // @ts-expect-error Root builder doesn’t accept attributes.\n        children.unshift(attributes)\n      } else if (typeof name === 'string') {\n        node = {type: 'element', name, attributes: {}, children: []}\n\n        if (isAttributes(attributes)) {\n          /** @type {string} */\n          let key\n\n          for (key in attributes) {\n            // Ignore nullish and NaN values.\n            if (\n              attributes[key] !== undefined &&\n              attributes[key] !== null &&\n              (typeof attributes[key] !== 'number' ||\n                !Number.isNaN(attributes[key]))\n            ) {\n              // @ts-expect-error Pretty sure we just set it.\n              node.attributes[key] = String(attributes[key])\n            }\n          }\n        } else {\n          children.unshift(attributes)\n        }\n      } else {\n        throw new TypeError('Expected element name, got `' + name + '`')\n      }\n\n      // Handle children.\n      while (++index < children.length) {\n        addChild(node.children, children[index])\n      }\n\n      return node\n    }\n  )\n\n/**\n * Add children.\n *\n * @param {Array<Child>} nodes\n *   List of nodes.\n * @param {Child} value\n *   Child.\n * @returns {void}\n *   Nothing.\n */\nfunction addChild(nodes, value) {\n  let index = -1\n\n  if (value === undefined || value === null) {\n    // Empty.\n  } else if (typeof value === 'string' || typeof value === 'number') {\n    nodes.push({type: 'text', value: String(value)})\n  } else if (Array.isArray(value)) {\n    while (++index < value.length) {\n      addChild(nodes, value[index])\n    }\n  } else if (typeof value === 'object' && 'type' in value) {\n    if (value.type === 'root') {\n      addChild(nodes, value.children)\n    } else {\n      nodes.push(value)\n    }\n  } else {\n    throw new TypeError('Expected node, nodes, string, got `' + value + '`')\n  }\n}\n\n/**\n * Check if `value` is `Attributes`.\n *\n * @param {Attributes | Child} value\n *   Value.\n * @returns {value is Attributes}\n *   Whether `value` is `Attributes`.\n */\nfunction isAttributes(value) {\n  if (\n    value === null ||\n    value === undefined ||\n    typeof value !== 'object' ||\n    Array.isArray(value)\n  ) {\n    return false\n  }\n\n  return true\n}\n","import type { Folder, Root } from \"@tmcw/togeojson\";\nimport type { Feature, FeatureCollection, Geometry, Position } from \"geojson\";\nimport { u } from \"unist-builder\";\nimport type { Element } from \"xast\";\nimport { toXml } from \"xast-util-to-xml\";\nimport { x } from \"xastscript\";\n\ntype F = Feature<Geometry | null>;\n\nconst BR = u(\"text\", \"\\n\");\nconst TAB = u(\"text\", \"  \");\n\ntype Literal = typeof BR;\n\n/**\n * Convert nested folder structure to KML. This expects\n * input that follows the same patterns as [toGeoJSON](https://github.com/placemark/togeojson)'s\n * kmlWithFolders method: a tree of folders and features,\n * starting with a root element.\n */\nexport function foldersToKML(root: Root): string {\n\treturn toXml(\n\t\tu(\"root\", [\n\t\t\tx(\n\t\t\t\t\"kml\",\n\t\t\t\t{ xmlns: \"http://www.opengis.net/kml/2.2\" },\n\t\t\t\tx(\n\t\t\t\t\t\"Document\",\n\t\t\t\t\troot.children.flatMap((child) => convertChild(child)),\n\t\t\t\t),\n\t\t\t),\n\t\t]),\n\t);\n}\n\n/**\n * Convert a GeoJSON FeatureCollection to a string of\n * KML data.\n */\nexport function toKML(\n\tfeatureCollection: FeatureCollection<Geometry | null>,\n): string {\n\treturn toXml(\n\t\tu(\"root\", [\n\t\t\tx(\n\t\t\t\t\"kml\",\n\t\t\t\t{ xmlns: \"http://www.opengis.net/kml/2.2\" },\n\t\t\t\tx(\n\t\t\t\t\t\"Document\",\n\t\t\t\t\tfeatureCollection.features.flatMap((feature) =>\n\t\t\t\t\t\tconvertFeature(feature),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t]),\n\t);\n}\n\nfunction convertChild(child: F | Folder) {\n\tswitch (child.type) {\n\t\tcase \"Feature\":\n\t\t\treturn convertFeature(child);\n\t\tcase \"folder\":\n\t\t\treturn convertFolder(child);\n\t}\n}\n\nfunction convertFolder(folder: Folder): Array<Literal | Element> {\n\tconst id = [\"string\", \"number\"].includes(typeof folder.meta.id)\n\t\t? {\n\t\t\t\tid: String(folder.meta.id),\n\t\t\t}\n\t\t: {};\n\treturn [\n\t\tBR,\n\t\tx(\"Folder\", id, [\n\t\t\tBR,\n\t\t\t...folderMeta(folder.meta),\n\t\t\tBR,\n\t\t\tTAB,\n\t\t\t...folder.children.flatMap((child) => convertChild(child)),\n\t\t]),\n\t];\n}\n\nconst META_PROPERTIES = [\n\t\"address\",\n\t\"description\",\n\t\"name\",\n\t\"open\",\n\t\"visibility\",\n\t\"phoneNumber\",\n] as const;\n\nfunction folderMeta(meta: Folder[\"meta\"]): Element[] {\n\treturn META_PROPERTIES.filter((p) => meta[p] !== undefined).map((p) => {\n\t\treturn x(p, [u(\"text\", String(meta[p]))]);\n\t});\n}\n\nfunction convertFeature(feature: F) {\n\tconst { id } = feature;\n\tconst idMember = [\"string\", \"number\"].includes(typeof id)\n\t\t? {\n\t\t\t\tid: id,\n\t\t\t}\n\t\t: {};\n\treturn [\n\t\tBR,\n\t\tx(\"Placemark\", idMember, [\n\t\t\tBR,\n\t\t\t...propertiesToTags(feature.properties),\n\t\t\tBR,\n\t\t\tTAB,\n\t\t\t...(feature.geometry ? [convertGeometry(feature.geometry)] : []),\n\t\t]),\n\t];\n}\n\nfunction join(position: Position): string {\n\treturn `${position[0]},${position[1]}`;\n}\n\nfunction coord1(coordinates: Position): Element {\n\treturn x(\"coordinates\", [u(\"text\", join(coordinates))]);\n}\n\nfunction coord2(coordinates: Position[]): Element {\n\treturn x(\"coordinates\", [u(\"text\", coordinates.map(join).join(\"\\n\"))]);\n}\n\nfunction valueToString(value: any): string {\n\tswitch (typeof value) {\n\t\tcase \"string\": {\n\t\t\treturn value;\n\t\t}\n\t\tcase \"boolean\":\n\t\tcase \"number\": {\n\t\t\treturn String(value);\n\t\t}\n\t\tcase \"object\": {\n\t\t\ttry {\n\t\t\t\treturn JSON.stringify(value);\n\t\t\t} catch (e) {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\";\n}\n\nfunction maybeCData(value: any) {\n\tif (\n\t\tvalue &&\n\t\ttypeof value === \"object\" &&\n\t\t\"@type\" in value &&\n\t\tvalue[\"@type\"] === \"html\" &&\n\t\t\"value\" in value &&\n\t\ttypeof value.value === \"string\"\n\t) {\n\t\treturn u(\"cdata\", value.value);\n\t}\n\n\treturn valueToString(value);\n}\n\nfunction propertiesToTags(properties: Feature[\"properties\"]): Element[] {\n\tif (!properties) return [];\n\tconst { name, description, visibility, ...otherProperties } = properties;\n\n\treturn [\n\t\tname && x(\"name\", [u(\"text\", valueToString(name))]),\n\t\tdescription && x(\"description\", [u(\"text\", maybeCData(description))]),\n\t\tvisibility !== undefined &&\n\t\t\tx(\"visibility\", [u(\"text\", visibility ? \"1\" : \"0\")]),\n\t\tx(\n\t\t\t\"ExtendedData\",\n\t\t\tObject.entries(otherProperties).flatMap(([name, value]) => [\n\t\t\t\tBR,\n\t\t\t\tTAB,\n\t\t\t\tx(\"Data\", { name: name }, [\n\t\t\t\t\tx(\"value\", [\n\t\t\t\t\t\tu(\n\t\t\t\t\t\t\t\"text\",\n\t\t\t\t\t\t\ttypeof value === \"string\" ? value : JSON.stringify(value),\n\t\t\t\t\t\t),\n\t\t\t\t\t]),\n\t\t\t\t]),\n\t\t\t]),\n\t\t),\n\t].filter(Boolean);\n}\n\nconst linearRing = (ring: Position[]): Element =>\n\tx(\"LinearRing\", [coord2(ring)]);\n\nfunction convertMultiPoint(geometry: GeoJSON.MultiPoint): Element {\n\treturn x(\n\t\t\"MultiGeometry\",\n\t\tgeometry.coordinates.flatMap((coordinates) => [\n\t\t\tBR,\n\t\t\tconvertGeometry({\n\t\t\t\ttype: \"Point\",\n\t\t\t\tcoordinates,\n\t\t\t}),\n\t\t]),\n\t);\n}\nfunction convertMultiLineString(geometry: GeoJSON.MultiLineString): Element {\n\treturn x(\n\t\t\"MultiGeometry\",\n\t\tgeometry.coordinates.flatMap((coordinates) => [\n\t\t\tBR,\n\t\t\tconvertGeometry({\n\t\t\t\ttype: \"LineString\",\n\t\t\t\tcoordinates,\n\t\t\t}),\n\t\t]),\n\t);\n}\n\nfunction convertMultiPolygon(geometry: GeoJSON.MultiPolygon): Element {\n\treturn x(\n\t\t\"MultiGeometry\",\n\t\tgeometry.coordinates.flatMap((coordinates) => [\n\t\t\tBR,\n\t\t\tconvertGeometry({\n\t\t\t\ttype: \"Polygon\",\n\t\t\t\tcoordinates,\n\t\t\t}),\n\t\t]),\n\t);\n}\n\nfunction convertPolygon(geometry: GeoJSON.Polygon): Element {\n\tconst [outerBoundary, ...innerRings] = geometry.coordinates;\n\treturn x(\"Polygon\", [\n\t\tBR,\n\t\tx(\"outerBoundaryIs\", [BR, TAB, linearRing(outerBoundary)]),\n\t\t...innerRings.flatMap((innerRing) => [\n\t\t\tBR,\n\t\t\tx(\"innerBoundaryIs\", [BR, TAB, linearRing(innerRing)]),\n\t\t]),\n\t]);\n}\n\nfunction convertGeometry(geometry: Geometry): Element {\n\tswitch (geometry.type) {\n\t\tcase \"Point\":\n\t\t\treturn x(\"Point\", [coord1(geometry.coordinates)]);\n\t\tcase \"MultiPoint\":\n\t\t\treturn convertMultiPoint(geometry);\n\t\tcase \"LineString\":\n\t\t\treturn x(\"LineString\", [coord2(geometry.coordinates)]);\n\t\tcase \"MultiLineString\":\n\t\t\treturn convertMultiLineString(geometry);\n\t\tcase \"Polygon\":\n\t\t\treturn convertPolygon(geometry);\n\t\tcase \"MultiPolygon\":\n\t\t\treturn convertMultiPolygon(geometry);\n\t\tcase \"GeometryCollection\":\n\t\t\treturn x(\n\t\t\t\t\"MultiGeometry\",\n\t\t\t\tgeometry.geometries.flatMap((geometry) => [\n\t\t\t\t\tBR,\n\t\t\t\t\tconvertGeometry(geometry),\n\t\t\t\t]),\n\t\t\t);\n\t}\n}\n"],"names":["subset","own","unsafe"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17]}